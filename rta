#!/usr/bin/env python3
import numpy as np
import soundfile as sf
import os
import time
from scipy.signal import resample
import argparse
from AudioSource import  RealTimeAudioSource, FileAudioSource
from AppMode import *
import pygame

# Update the dimensions of the fft_data and vol_data arrays
plot_width = screen.get_width()
plot_height = screen.get_height()
vol_data = np.zeros(plot_width)

TIME_BINS = plot_height
FFT_FREQ_BINS = plot_width // 2 + 1
fft_data = np.zeros((FFT_FREQ_BINS, TIME_BINS))

ACF_FREQ_BINS = plot_width // 2 + 1
acf_data = np.zeros((ACF_FREQ_BINS, TIME_BINS))

def compute_volume(signal):
    global vol_data
    # Compute RMS (root mean square) volume of the signal
    vol_data = np.roll(vol_data, -1, axis=0)
    rms = np.sqrt(np.mean(signal ** 2))
    spl = round(20 * np.log10(np.where(rms < 1e-6, 1e-6, rms)),1)  # Convert to dB
    vol_data[-1] = spl
    print(spl)

def compute_smoothed_fft(signal, samplerate, previous_fft=None, alpha=0.2):
    pass

class AudioVisualizer:
    def __init__(self):
        self.spl_mode = SPLMode(vol_data)
        self.rta_mode = None
        self.acf_mode = None
        self.current_mode = self.spl_mode # initial mode
        self.current_mode.setup_plot(vol_data)

    def switch_mode(self, mode_name):
        if mode_name == 'RTA':
            pass #self.current_mode = self.rta_mode
        elif mode_name == 'SPL':
            self.current_mode = self.spl_mode
            self.current_mode.setup_plot(vol_data)
        elif mode_name == 'Autocorr':
            pass# self.current_mode = self.acf_mode
        else:
            raise ValueError(f"Invalid mode: {mode_name}")
        self.redraw()

    def redraw(self):
        self.current_mode.setup_plot()

    def process_audio_chunk(self, audio_chunk, samplerate):
        global vol_data
        compute_volume(audio_chunk)
        compute_smoothed_fft(audio_chunk, samplerate)
        if self.current_mode == self.spl_mode:
            self.current_mode.update_plot(vol_data)

def scan_buttons():
    # Simulate scanning for button presses
    return None

if __name__ == '__main__':
    argparse = argparse.ArgumentParser(description='Audio Visualizer')
    argparse.add_argument('--mode', choices=['SPL', 'RTA','Autocorr'], default="SPL", help='Mode to run the visualizer in')
    # change to default once we have hardware
    argparse.add_argument('--source', type=str, default='testdata', help='Use test data instead of real-time audio')
    argparse.add_argument('--windowsize', type=int, default=16384, help='Window size for FFT')
    args = argparse.parse_args()

    windowsize = int(args.windowsize)
    if args.source == 'testdata':
        audio_source = FileAudioSource('testdata', chunksize=windowsize)
        samplerate = 48000
    else:
        samplerate = 44100 # for now - need to get this from the audio source
        audio_source = RealTimeAudioSource(chunksize=windowsize)

    visualizer = AudioVisualizer()

    try:
        while True:
            button_press = scan_buttons()
            if button_press:
                pass
                #visualizer.switch_mode(button_press)                
            chunk = next(audio_source)
            visualizer.process_audio_chunk(chunk, samplerate)
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    raise KeyboardInterrupt

    except KeyboardInterrupt:
        print('Goodbye')
    finally:
        pygame.quit()